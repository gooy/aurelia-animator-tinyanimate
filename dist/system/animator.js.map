{"version":3,"sources":["animator.js"],"names":[],"mappings":"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","file":"animator.js","sourceRoot":"/source/","sourcesContent":["import TinyAnimate from 'tinyanimate';\nimport JSOL from 'jsol';\n\n/**\n * Aurelia animator implementation using TinyAnimate\n */\nexport class TinyAnimator{\n\n  effects = {};\n  timelines = {};\n\n  /**\n   * Default options for the animation\n   * @type {Object}\n   */\n  options = {\n    duration: 500\n  };\n\n  easings = [];\n\n  /**\n   * Default enter animation\n   * @type {Object}\n   */\n  enterAnimation = {properties:\"fadeIn\",options:{duration:200}};\n  /**\n   * Default leave animation\n   * @type {Object}\n   */\n  leaveAnimation = {properties:\"fadeOut\",options:{duration:200}};\n\n  isAnimating = false;\n\n  constructor(){\n    this.easings = Object.keys(TinyAnimate.easings).sort();\n\n    this.registerEffect(\"fadeIn\",{opacity:1});\n    this.registerEffect(\"fadeOut\",{opacity:0});\n  }\n\n  /**\n   * Run a animation by name or by manually specifying properties and options for it\n   *\n   * @param element {HTMLElement}   Element to animate\n   * @param effectName {Object}     Element properties to animate\n   * @param options {Object}        Animation options\n   *\n   * @returns {Promise} resolved when animation is complete\n   */\n  animate(element,effectName,options){\n\n    this.isAnimating = true;\n\n    return new Promise((resolve, reject) => {\n\n      var defaults = {\n        onComplete:elements=>{\n          this.isAnimating = false;\n          resolve(true);\n        }\n      };\n      options = Object.assign({},this.options,defaults,options);\n\n      var properties = this.effects[effectName];\n      options = Object.assign(options, properties);\n\n      var duration = parseInt(options.duration);\n      delete options.duration;\n\n      var easing = options.easing;\n      delete options.easing;\n\n      if(effectName===\"fadeIn\"){\n        element.style.opacity = 0;\n      }\n\n      // TinyAnimate.animate(from, to, duration, update, easing, done)\n      // TinyAnimate.animateCSS(element, property, unit, from, to, duration, easing, done)\n\n      var cb = function() {resolve(true);};\n      var property,_from,to,unit=null;\n      for(property in properties){\n        to = properties[property];\n        _from = parseInt(element.style[property])||0;\n        console.log('property', property,unit,_from,to,duration,easing);\n        TinyAnimate.animateCSS(element, property, unit, _from, to, duration, easing, cb);\n        cb = null;\n      };\n\n    });\n\n  }\n\n  /**\n   * Run the enter animation on an element\n   *\n   * @param element {HTMLElement}   Element to animate\n   * @returns {Promise} resolved when animation is complete\n   */\n  enter(element) {\n    return this._runElementAnimation(element,\"enter\");\n  }\n\n  /**\n   * Run the leave animation on an element\n   *\n   * @param element {HTMLElement}   Element to animate\n   * @returns {Promise} resolved when animation is complete\n   */\n  leave(element) {\n    return this._runElementAnimation(element,\"leave\");\n  }\n\n  /**\n   * Run a seqeunce of animations, one after the other\n   *\n   * @param sequence {Array}  array of animations\n   */\n  runSequence(sequence){\n    return Promise.resolve(false);\n  }\n\n  /**\n   * Register a new effect by name\n   *\n   * @param effectName {String}   name of the effect\n   * @param properties {Object}   properties for the effect\n   */\n  registerEffect(effectName,properties){\n    this.effects[effectName] = properties;\n  }\n\n  /**\n   * Unregister a new effect by name\n   *\n   * @param effectName {String}   name of the effect\n   */\n  unregisterEffect(effectName,properties){\n    delete this.effects[effectName];\n  }\n\n  //--------------------------------- Private methods\n\n  /**\n   * Run animation by type name\n   *\n   * @param element {HTMLElement}   Element to animate\n   * @param name {String}           Name of the animation to run\n   *\n   * @returns {Promise} resolved when animation is complete\n   */\n  _runElementAnimation(element,name){\n    var properties = {};\n    var options = {};\n\n    //parse animation properties for this element if none were found\n    if(!element.animations) this._parseAnimations(element);\n\n    if(element.animations[name]) {\n      properties = element.animations[name].properties;\n      options = element.animations[name].options;\n    }\n\n    //skip if no enter animation was specified\n    if(!properties) return Promise.resolve(false);\n\n    return this.animate(element,properties,options);\n  }\n\n  /**\n   * Parse animations specified in the elements attributes\n   *\n   * @param element {HTMLElement}   Element to parse animations from\n   */\n  _parseAnimations(element){\n    element.animations = {};\n    element.animations.enter = this.parseAttributeValue(element.getAttribute(\"animation-enter\"))||this.enterAnimation;\n    element.animations.leave = this.parseAttributeValue(element.getAttribute(\"animation-leave\"))||this.leaveAnimation;\n  }\n\n  /**\n   * Parse an attribute value as an animation definition\n   *\n   * syntax with effectname:     effectName:{prop1:value,prop2:value}\n   * syntax with properties:     {prop1:value,prop2:value}:{prop1:value,prop2:value}\n   *\n   * @param value           Attribute value\n   * @returns {Object}      Object with the effectName/properties and options that have been extracted\n   */\n  parseAttributeValue(value){\n    if(!value) return value;\n    var p = value.split(\";\");\n    var properties = p[0];\n    var options = {};\n    if(properties[0]==\"{\" && properties[properties.length-1] == \"}\") properties = JSOL.parse(properties);\n\n    if(p.length>1) {\n      options = p[1];\n      options = JSOL.parse(options);\n    }\n    return {properties,options};\n  }\n\n}\n"]}